<!DOCTYPE html>
<meta charset="utf-8">
<style>
.world_map_border {
  fill: none;
  pointer-events: all;
}

.feature {
  fill: #ccc;
  cursor: pointer;
}

.feature.active {
  fill: orange;
}

.mesh {
  fill: none;
  stroke: #fff;
  stroke-linecap: round;
  stroke-linejoin: round;
}
</style>
<html>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/topojson.v2.min.js"></script>
<body>
  <h1 style="text-align:center">
    A Visual Narrative on the status of trade across modern global economies
  </h1>
  <svg id="world_map"></svg>
  <button id="back_button" onclick="backClicked()" disabled>PREV</button>
  <button id="front_button" onclick="frontClicked()">NEXT</button>
  <text id="country_name"></text>
  <p id="bottom_narrative"></p>
</body>

<script>  // Const Text strings
  const text_slide_0 = `
  Trade is an essential part of the global supply chain.
  However, every country partakes in this differently on the global stage.
  The following graph shows us what % of each country's GDP is attributed to trade.
  This is also known as Trade Openness Ratio (see https://en.wikipedia.org/wiki/Trade-to-GDP_ratio).
  From this graph we observe that nations like <TODO/Singapore> and <TODO> rely heavily on international trade while
  larger economies like <TODO/Japan> and <TODO/USA> do not.`;
  const text_slide_1 = `
  While current state of affairs look this way, it is interesting to see how national priorities have changed historically.
  This helps paint a picture of how much countries have prioritized international trade over the years. `;
  const text_slide_2 = `
  That said, it is important to note that while countries may place greater or lower importance on trade,
  they may do so differently. Some might prefer to simply import goods that their nation requires,
  while others looks to exporting various products from within their borders.
  In this graph, we see how each country leverages trade.
  Feel free to click into each country to dive deeper into how trade breaks down.
  Red countries are nations with a net import, and Blue countries are nations with a net export.`;
</script>

<script>  // Slides
class Slide {
  constructor(text) {
    this.bottom_narrative = text;
    this.data = []
  }

  attachDatum(isoAlphaId, datum) {
    if (this.data[isoAlphaId] == null) {
      this.data[isoAlphaId] = datum;
    } else {
      console.log("ERROR - attachDatum has existing value");
    }
  }

  getDatum(isoAlphaId) {
    return this.data[isoAlphaId];
  }

  updateDatum(isoAlphaId, newDatum) {
    if (this.data[isoAlphaId] == null) {
      console.log("WARNING - update called on data that was non-existant");
    }
    this.data[isoAlphaId] = newDatum;
  }

  getSizeOfData() {
    return Object.entries(this.data).length;
  }

  computeDomain() {
    var smallest = null,
        largest = null;
    this.sortedDataValues = [];

    for (const [key, value] of Object.entries(this.data)) {
      if (value == undefined) {continue;}

      var v = parseFloat(value);

      if (v == undefined || v == NaN || v == null) {
        console.log("ERROR: parseFloat is acting funny", value, v, key);
      }

      this.sortedDataValues.push(v);

      if (smallest == null) {
        smallest = v;
      } else if (v < smallest) {
        smallest = v;
      }

      if (largest == null) {
        largest = v;
      } else if (v > largest) {
        largest = v;
      }
    }
    this.domain_min = smallest;
    this.domain_max = largest;

    this.sortedDataValues.sort(function(a,b) { return a - b;});
  }

  getPctIdx(pct, length) {
    return parseInt(pct * length / 100);
  }

  printPct() {  // purely debug function
    [0,1,5,10,25,35,50,65,75,90,95,99,100].forEach(num => {
      var idx = parseInt(num * length / 100);
      console.log(this.sortedDataValues[idx]);
    });
  }

  getDomain() {
    var length = parseInt(this.sortedDataValues.length) - 1;
    var lowerPct = this.getPctIdx(0, length);
    var midPct = this.getPctIdx(50, length);
    var upperPct = this.getPctIdx(100, length);

    var r = [
      this.sortedDataValues[lowerPct],
      this.sortedDataValues[midPct],
      this.sortedDataValues[upperPct]];
    return r;
  }

  getScales() {
    if (this.scales == undefined) {
      var domain = this.getDomain();
      domain[1] = 0;
      this.scales = d3.scaleLinear()
                      .domain(domain)
                      .range(['red', 'pink', 'blue']);
      var matchingScales = [];
      domain.forEach(r => matchingScales.push(this.scales(r)));
      console.log(
        "In getScales() --> domain = ", domain,
        "\nCorresponding scales: ", matchingScales);
    }
    return this.scales;
  }
}

var slides = []
slides[0] = new Slide(text_slide_0);
slides[1] = new Slide(text_slide_1);
slides[2] = new Slide(text_slide_2);
</script>

<script>
var width = window.innerWidth;
var height = window.innerHeight;

var graphWidth = width;
var graphHeight = 80 * height / 100;

var active = d3.select(null);
var projection = d3.geoMercator()
    .scale(150)  // TODO: What is the right scale for dynamic width/height
    .translate([width / 2, height / 2]);

var bottom_narrative = d3.select("#bottom_narrative")
    .attr("width", width)
    .attr("height", height * 10 / 100);
var svg = d3.select("#world_map")
    .attr("width", graphWidth)
    .attr("height", graphHeight)
    .on("click", stopped, true);
var back_button = d3.select("#back_button")
    .attr("width", width * 10 / 100)
    .attr("height", height * 10 / 100);
var front_button = d3.select("#front_button")
    .attr("width", width * 10 / 100)
    .attr("height", height * 10 / 100);
var country_name = d3.select("#country_name")
    .attr("width", width * 80 / 100)
    .attr("height", height * 10 / 100);

var currentSlide = 0;

svg.append("rect")
    .attr("class", "world_map_border")
    .attr("width", graphWidth)
    .attr("height", graphHeight)
    .on("click", reset);
var g = svg.append("g");

var zoom = d3.zoom().on("zoom", zoomed);
svg.call(zoom);

var idToAlpha = [];
var WDIData = [];
var path = d3.geoPath().projection(projection);
d3.queue()
.defer(d3.csv, "https://abhishek-srikanth.github.io/projects/UIUC_DataVis/iso_numeric_to_alpha.csv")
.defer(d3.csv, "https://abhishek-srikanth.github.io/projects/UIUC_DataVis/WDI_Trade_Data_2021Jun22.csv")
.defer(d3.json, "https://gist.githubusercontent.com/mbostock/4090846/raw/d534aba169207548a8a3d670c9c2cc719ff05c47/world-50m.json")
.await(function(error, iso_numeric_to_alpha, wdi_trade_data, world) {
    if (error) throw error;

    for (var i = 0; i < iso_numeric_to_alpha.length; i++) {
      idToAlpha[iso_numeric_to_alpha[i].ISO3166_1_numeric] =
          iso_numeric_to_alpha[i].ISO3166_1_Alpha_3;
    }

    for (var i = 0; i < wdi_trade_data.length; i++) {
      var wdi_trade_datum = wdi_trade_data[i];
      var isoAlphaId = wdi_trade_datum["Country Code"];
      var indicatorCode = wdi_trade_datum["Indicator Code"];
      switch(indicatorCode) {
        case "NE.TRD.GNFS.ZS":  // Trade (% of GDP)
          var mostRecent = getValueFromMostRecentYear(wdi_trade_datum);
          if (mostRecent == undefined) { continue; }
          slides[0].attachDatum(isoAlphaId, mostRecent);
        break;
        case "NE.RSB.GNFS.ZS": // External balance on goods and services (% of GDP)
          var oldest = getValueFromOldestYear(wdi_trade_datum);
          var mostRecent = getValueFromMostRecentYear(wdi_trade_datum);
          var difference = mostRecent - oldest;
          if (mostRecent == undefined) { continue; }
          slides[1].attachDatum(isoAlphaId, difference);
        break;
        case "NE.IMP.GNFS.ZS": // Imports of goods and services (% of GDP)
          // (-1 * ..) used since imports are considered in the negative
          var mostRecent = getValueFromMostRecentYear(wdi_trade_datum);
          if (mostRecent == undefined) { continue; }
          mostRecent *= -1;
          var currentDatum = slides[2].getDatum(isoAlphaId);
          if (currentDatum == null) {
            slides[2].attachDatum(isoAlphaId, mostRecent);
          } else {
            slides[2].updateDatum(isoAlphaId, currentDatum + mostRecent);
          }
        break;
        case "NE.EXP.GNFS.ZS": // Exports of goods and services (% of GDP)
          var mostRecent = getValueFromMostRecentYear(wdi_trade_datum);
          if (mostRecent == undefined) { continue; }
          var currentDatum = slides[2].getDatum(isoAlphaId);
          if (currentDatum == null) {
            slides[2].attachDatum(isoAlphaId, mostRecent);
          } else {
            slides[2].updateDatum(isoAlphaId, currentDatum + mostRecent);
          }
        break;
      }
      var key = [isoAlphaId, indicatorCode];
      WDIData[key] = wdi_trade_data[i];
    }

    slides.forEach(slide => {  // Log some data to console for debugging
      slide.computeDomain();
    });

    g.selectAll("path")
        .data(topojson.feature(world, world.objects.countries).features)
      .enter().append("path")
        .attr("d", path)
        .attr("class", "feature")
        .on("click", clicked);
    g.append("path")
        .datum(topojson.mesh(
          world, world.objects.countries, function(a, b) { return a !== b; }))
        .attr("class", "mesh")
        .attr("d", path);

    // Now that we have our data, and the map is created, we can populate our slides.
    populateSlide(slides[currentSlide]);

});

function clicked(d) {
  if (active.node() === this) return reset();
  active.classed("active", false);
  active = d3.select(this).classed("active", true);
  d3.select("#country_name").text(d.id + " --> " + idToAlpha[d.id]);

  var bounds = path.bounds(d),
      dx = bounds[1][0] - bounds[0][0],
      dy = bounds[1][1] - bounds[0][1],
      x = (bounds[0][0] + bounds[1][0]) / 2,
      y = (bounds[0][1] + bounds[1][1]) / 2,
      // TODO: in below, width and height need to be the size of the svg
      //       and not that of the entire window.
      scale = Math.max(1, Math.min(8, 0.9 / Math.max(dx / graphWidth, dy / graphHeight))),
      translate = [graphWidth / 2 - scale * x, graphHeight / 2 - scale * y];

  svg.transition()
      .duration(750)
      .call(zoom.transform, d3.zoomIdentity.translate(translate[0],translate[1]).scale(scale));
}

function reset() {
  active.classed("active", false);
  active = d3.select(null);

  svg.transition()
      .duration(750)
      .call(zoom.transform, d3.zoomIdentity);
}

function zoomed() {
  g.style("stroke-width", 1.5 / d3.event.transform.k + "px");
  g.attr("transform", d3.event.transform);
}

// If the drag behavior prevents the default click,
// also stop propagation so we don’t click-to-zoom.
function stopped() {
  if (d3.event.defaultPrevented) d3.event.stopPropagation();
}

function populateSlide(slide) {
  bottom_narrative.text(slide.bottom_narrative);
  console.log("populate slide called");

  d3.selectAll(".feature").each(function(d) {
    d3.select(this)
      .style("fill", function(d) {
        isoNumericId = d.id;
        isoAlphaId = idToAlpha[isoNumericId];
        var slide = slides[currentSlide];
        var datum = slide.getDatum(isoAlphaId);
        return slide.getScales()(datum);
      });
  });
}

function getValueFromOldestYear(datum) {
  for (var i = 1960; i <= 2020; i++) {
    if (datum[i.toString()] != "") {
      return parseFloat(datum[i.toString()]);
    }
  }
}

function getValueFromMostRecentYear(datum) {
  for (var i = 2020; i >= 1960; i--) {
    if (datum[i.toString()] != "") {
      return parseFloat(datum[i.toString()]);
    }
  }
}

function backClicked() {
    console.log("Back Clicked");
  if (currentSlide <= 0) {
    return;
  }
  currentSlide -= 1;
  reset();
  populateSlide(slides[currentSlide]);

  // Now we will update button disabled state
  if (currentSlide == 0) {
    back_button.attr("disabled", true);
  }
  if (currentSlide + 1 == slides.length - 1) {
    front_button.attr("disabled", null);
  }
}

function frontClicked() {
  console.log("Front Clicked");
  if (currentSlide >= slides.length) {
    return;
  }

  currentSlide += 1;
  reset();
  populateSlide(slides[currentSlide]);

  // Now we will update button disabled state
  if (currentSlide == slides.length - 1) {
    front_button.attr("disabled", true);
  }
  if (currentSlide > 0) {
    back_button.attr("disabled", null);
  }
}

</script>
</html>
